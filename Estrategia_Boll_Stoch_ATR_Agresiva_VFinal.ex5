//+------------------------------------------------------------------+
//|  Estrategia Boll Stoch ATR Agresiva VFinal (EA MQL5)            |
//+------------------------------------------------------------------+
#property strict
#include <Trade\Trade.mqh>
#include <so_report.mqh>

CTrade trade;

//=============================//
//  PARÃMETROS CONFIGURABLES   //
input int    bb_period                      = 20;
input double bb_deviation                   = 2.0;
input int    sto_period_k                   = 14;
input int    sto_period_d                   = 3;
input int    sto_slowing                    = 3;
input ENUM_TIMEFRAMES timeframe_indicadores = PERIOD_CURRENT;

input double lot_size                       = 0.01;
input int    sl_atr_multiplier              = 20;
input int    tp_atr_multiplier              = 2;
input double atrMultiplierTrailing          = 0.5;
input double margen_cruce                   = 0.5;

//=============================//
//   PARÃMETROS GENERALES      //
input double minDistanceToTPMultiplier      = 0.5;
input bool   allow_one_order_per_symbol     = true;
input bool   allow_one_order_per_account    = false;
input int    atr_period                     = 14;

//=============================//
int bb_handle=INVALID_HANDLE, sto_handle=INVALID_HANDLE, atr_handle=INVALID_HANDLE;

//=============================//
//   Helpers de exportaciÃ³n    //
string BuildInputsJSON()
{
  string inputs_json="{";
  inputs_json += "\"bb_period\":"+IntegerToString((int)bb_period)+",";
  inputs_json += "\"bb_deviation\":"+DoubleToString((double)bb_deviation,2)+",";
  inputs_json += "\"sto_period_k\":"+IntegerToString((int)sto_period_k)+",";
  inputs_json += "\"sto_period_d\":"+IntegerToString((int)sto_period_d)+",";
  inputs_json += "\"sto_slowing\":"+IntegerToString((int)sto_slowing)+",";
  inputs_json += "\"timeframe_indicadores\":\""+EnumToString(timeframe_indicadores)+"\",";
  inputs_json += "\"lot_size\":"+DoubleToString(lot_size,2)+",";
  inputs_json += "\"sl_atr_multiplier\":"+IntegerToString((int)sl_atr_multiplier)+",";
  inputs_json += "\"tp_atr_multiplier\":"+IntegerToString((int)tp_atr_multiplier)+",";
  inputs_json += "\"atrMultiplierTrailing\":"+DoubleToString(atrMultiplierTrailing,2)+",";
  inputs_json += "\"margen_cruce\":"+DoubleToString(margen_cruce,2)+",";
  inputs_json += "\"minDistanceToTPMultiplier\":"+DoubleToString(minDistanceToTPMultiplier,2)+",";
  inputs_json += "\"allow_one_order_per_symbol\":"+string(allow_one_order_per_symbol?"true":"false")+",";
  inputs_json += "\"allow_one_order_per_account\":"+string(allow_one_order_per_account?"true":"false")+",";
  inputs_json += "\"atr_period\":"+IntegerToString((int)atr_period)+",";
  inputs_json += "\"symbol\":\""+_Symbol+"\"";
  inputs_json += "}";
  return inputs_json;
}

//=============================//
//         INIT / DEINIT       //
int OnInit()
{
  // iBands(symbol, tf, period, shift, deviation, price)
  bb_handle  = iBands(_Symbol, timeframe_indicadores, (int)bb_period, (int)0, (double)bb_deviation, (ENUM_APPLIED_PRICE)PRICE_CLOSE);
  if(bb_handle==INVALID_HANDLE){ Print("âŒ iBands invÃ¡lido"); return INIT_FAILED; }

  // iStochastic(symbol, tf, K, D, Slowing, MA, PRICE)
  sto_handle = iStochastic(_Symbol, timeframe_indicadores, (int)sto_period_k, (int)sto_period_d, (int)sto_slowing, (ENUM_MA_METHOD)MODE_SMA, (ENUM_STO_PRICE)STO_LOWHIGH);
  if(sto_handle==INVALID_HANDLE){ Print("âŒ iStochastic invÃ¡lido"); return INIT_FAILED; }

  atr_handle = iATR(_Symbol, timeframe_indicadores, (int)atr_period);
  if(atr_handle==INVALID_HANDLE){ Print("âŒ iATR invÃ¡lido"); return INIT_FAILED; }

  string tag = (StringLen(so_run_id)>0 ? so_run_id : "run_auto");
  PrintFormat("RUN_START %s | TF=%s", tag, EnumToString(timeframe_indicadores));
  return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
  // Exportar SIEMPRE al finalizar el test simple (y tambiÃ©n Ãºtil en vivo)
  if(MQLInfoInteger(MQL_TESTER))
  {
    string inputs_json = BuildInputsJSON();
    SO_ReportOnTesterDeinit(inputs_json);

    double fb = AccountInfoDouble(ACCOUNT_BALANCE);
    string tag = (StringLen(so_run_id)>0 ? so_run_id : "run_auto");
    PrintFormat("final balance %.2f USD | run_tag=%s", fb, tag);
    PrintFormat("RUN_END %s", tag);
  }
}

//=============================//
//    UTILIDADES DE CONTROL    //
bool IsOrderOpen()
{
  for(int i=0;i<PositionsTotal();i++)
  {
    ulong tk = PositionGetTicket(i);
    if(PositionSelectByTicket(tk))
    {
      string sym = PositionGetString(POSITION_SYMBOL);
      if(allow_one_order_per_symbol  && sym==_Symbol) return true;
      if(allow_one_order_per_account) return true;
    }
  }
  return false;
}

void ExecuteOrder(const string type, const double price, const double sl, const double tp)
{
  if(IsOrderOpen()){ Print("â›” Orden NO ejecutada: ya hay una posiciÃ³n abierta."); return; }
  if(type=="BUY"){  if(trade.Buy (lot_size,_Symbol,price,sl,tp)) Print("ðŸŸ¢ BUY enviada | SL:", sl, " | TP:", tp); }
  if(type=="SELL"){ if(trade.Sell(lot_size,_Symbol,price,sl,tp)) Print("ðŸ”´ SELL enviada | SL:", sl, " | TP:", tp); }
}

//=============================//
//     TRAILING POR ATR        //
void ManageTrailingStop()
{
  if(!PositionSelect(_Symbol)) return;

  double v[1]; if(CopyBuffer(atr_handle,0,0,1,v)<=0 || v[0]<=0) return;
  double atr = v[0];

  double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
  double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
  double slc = PositionGetDouble(POSITION_SL);
  double tp  = PositionGetDouble(POSITION_TP);
  long   typ = PositionGetInteger(POSITION_TYPE);
  double op  = PositionGetDouble(POSITION_PRICE_OPEN);

  double mind = atr*minDistanceToTPMultiplier;
  double nsl;

  if(typ==POSITION_TYPE_BUY)
  {
    if(bid<=op) return;
    nsl = NormalizeDouble(bid - atr*atrMultiplierTrailing, _Digits);
    if( (slc<=0 || nsl>slc) && (tp-nsl)>mind && nsl>op )
      if(trade.PositionModify(_Symbol,nsl,tp)) Print("ðŸ” TS (BUY) actualizado: SL =", nsl);
  }
  else if(typ==POSITION_TYPE_SELL)
  {
    if(ask>=op) return;
    nsl = NormalizeDouble(ask + atr*atrMultiplierTrailing, _Digits);
    if( (slc<=0 || nsl<slc) && (nsl-tp)>mind && nsl<op )
      if(trade.PositionModify(_Symbol,nsl,tp)) Print("ðŸ” TS (SELL) actualizado: SL =", nsl);
  }
}

//=============================//
//           ONTICK            //
void OnTick()
{
  ManageTrailingStop();

  double up[1], lo[1], k[1], d[1], a[1];
  if(CopyBuffer(bb_handle,1,0,1,up)<=0) return;   // upper
  if(CopyBuffer(bb_handle,2,0,1,lo)<=0) return;   // lower
  if(CopyBuffer(sto_handle,0,0,1,k)<=0) return;   // %K
  if(CopyBuffer(sto_handle,1,0,1,d)<=0) return;   // %D
  if(CopyBuffer(atr_handle,0,0,1,a)<=0 || a[0]<=0) return; // ATR

  double close = iClose(_Symbol, PERIOD_CURRENT, 0);
  double ask   = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
  double bid   = SymbolInfoDouble(_Symbol,SYMBOL_BID);

  // Reglas iguales a VFinal
  bool priceBuy  = (close < lo[0]);
  bool stochBuy  = (k[0] < 20 && k[0] > d[0] && (k[0]-d[0]) > margen_cruce);

  bool priceSell = (close > up[0]);
  bool stochSell = (k[0] > 80 && k[0] < d[0] && (d[0]-k[0]) > margen_cruce);

  if(priceBuy && stochBuy)
  {
    double sl = NormalizeDouble(ask - a[0]*sl_atr_multiplier, _Digits);
    double tp = NormalizeDouble(ask + a[0]*tp_atr_multiplier, _Digits);
    PrintFormat("âœ… BUY: Close=%.5f | Lower=%.5f | K=%.2f | D=%.2f | K-D=%.2f", close, lo[0], k[0], d[0], (k[0]-d[0]));
    ExecuteOrder("BUY", ask, sl, tp);
  }
  if(priceSell && stochSell)
  {
    double sl = NormalizeDouble(bid + a[0]*sl_atr_multiplier, _Digits);
    double tp = NormalizeDouble(bid - a[0]*tp_atr_multiplier, _Digits);
    PrintFormat("âœ… SELL: Close=%.5f | Upper=%.5f | K=%.2f | D=%.2f | D-K=%.2f", close, up[0], k[0], d[0], (d[0]-k[0]));
    ExecuteOrder("SELL", bid, sl, tp);
  }
}

//=============================//
//       OnTesterDeinit        //
void OnTesterDeinit()
{
  string inputs_json = BuildInputsJSON();
  SO_ReportOnTesterDeinit(inputs_json);

  double fb=AccountInfoDouble(ACCOUNT_BALANCE);
  string tag=(StringLen(so_run_id)>0? so_run_id : "run_auto");
  PrintFormat("final balance %.2f USD | run_tag=%s", fb, tag);
  PrintFormat("RUN_END %s", tag);
}
